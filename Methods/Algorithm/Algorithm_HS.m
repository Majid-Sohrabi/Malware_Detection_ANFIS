function Result=Algorithm_HS(Model,Parameter)
tic;
disp('Starting HS ...');
MaxIteration =1000;
HMS =50;
HMCR =0.8;
PAR =0.3;
X_MIN=Model.VarMin;
X_MAX=Model.VarMax;
%% Problem Definition
costfunction=@(q)Model.Fitness(q);

nvar=Model.nVar;
VarSize=[1,nvar];
%% Intialization

% Intialize Population
Harmony.position=[];
Harmony.cost=[];

pop=repmat(Harmony,HMS,1);

pop(1).position=ones(VarSize);
pop(1).cost=costfunction(pop(1).position);
for i=2:HMS
    %Intialize Position
    pop(i).position=unifrnd(X_MIN,X_MAX,VarSize);
    %Evaluation
    pop(i).cost=costfunction(pop(i).position);
end

%Sort Population
costs=[pop.cost];
[cost locateofsortedcost]=sort(costs);
pop=pop(locateofsortedcost);

%Hold Best Cost Value
Bestcost=zeros(MaxIteration,1);
Time=zeros(MaxIteration,1);
Time(1)=toc;
%% harmony Search Main Loop
for it=1:MaxIteration
    tic;
    for j=1:nvar
        
        %harmony memory
        r=rand();
        
        if r<HMCR
            r1=randi(HMS,1,1);
            newpop.position(j)=pop(r1).position(j);
            
            %pitch adjusting
            r2=rand();
            
            if r2<PAR
                newpop.position(j)=newpop.position(j)+rand()*X_MAX;
            end
            
        else
            %random solution
            newpop.position(j)=X_MIN+rand()*(X_MAX-X_MIN);
        end
    end
    %evaluation of new solution
    newpop.cost=costfunction(newpop.position);
    
    %compariong Xnew and worth harmony in harmony memory
    if newpop.cost<costs(end)
        pop=vertcat(pop(1:HMS-1,:),newpop);
    end
    %sort new population
    costs=[pop.cost];
    [cost locateofsortedcost]=sort(costs);
    pop=pop(locateofsortedcost);
    %sort best cost
    Bestcost(it)=pop(1).cost;
    disp(['It : ' , num2str(it),' Cost : ',num2str(Bestcost(it))]);
    Time(it)=Time(it)+toc;
end
disp('End of HS.');
%% Results
Result.BestSol=pop(1);
Result.Population=pop;
Result.BestCost=Bestcost;
Result.Time=Time;
end